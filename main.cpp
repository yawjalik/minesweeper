// MINESWEEPER!!!
// Group 19: Jalik, Raph
// Description: yadayadayada

// ASCII text generated by https://fsymbols.com/text-art/
// Text symbols (in print_board) generated by https://www.madeintext.com/text-symbols/

#include <iostream>
#include <chrono>
#include "functions.h"
#include "prints.h"
#include "board.h"
using namespace std;


int main()
{
    // Main Menu
    string command;

    while (true)
    {
    	// Create instance of a board
    	Board board;

        // Print main menu and get input:
        clear_screen();
        print_title();
        getline(cin, command);

        bool quit = false;  // To check if player quits in the first move
        int previous_time = 0;

        if (command == "0")
        {
            clear_screen();
            print_instructions();
            continue;
        }
        else if (command == "1")
        {
            // Initialize board based on difficulty
            board.select_difficulty();
            board.initialize_board();

            string input;
            int row, col;

            // First move: making sure first input isn't near a bomb
            while(true)
            {
				clear_screen();
                board.print_board(board.covered_board);
                cout << ">> ";
                getline(cin, input); // a0, b1, etc.

            	// Exit and save commands
		        if (input == "quit" || input == "q")
		        {
		        	quit = true;
		            break;
		        }
		        else if (input == "save")
		        {
		        	cout << "Make your first move first!" << endl;
		        	cout << "Press ENTER to continue";
		        	getline(cin, input);
		        	continue;
		        }

                if (is_2digit_coord(input))
                {
                    row = input[0] - 'a';
                    col = input[2] - '0' + 10;
                }
                else if (is_1digit_coord(input))
                {
                    row = input[0] - 'a';
                    col = input[1] - '0';
                }
                else
                	continue;

                // Additional check for limit
                if (row >= board.ROWS || col >= board.COLS)
                    continue;

                board.generate_mines(row, col);
                board.generate_clues();
                if (board.raw_board[row][col] == '0')
                    board.flood_fill(row, col);
                else
                	board.covered_board[row][col] = board.raw_board[row][col];
                break;
            }

        }
        else if (command == "2")
        {
        	string input;

			// Load board
		    if (!board.load_board(previous_time))
		    {
			    cout << "No save file detected!\nPress ENTER to return to menu" << endl;
	        	getline(cin, input);
	        	continue;
		    }
        }
        else if (command == "3")
        {
        	clear_screen();
            print_end();
            break;
        }
        else
        {
            continue;
        }

        /***************** GAME BEGINS *****************/

        // Variables
	    string input;
	    int row, col;
	    bool flag;

	    // Start the timer
	    auto begin = chrono::high_resolution_clock::now();

	    while (!quit)
	    {
	        flag = false;
	        clear_screen();
	        board.print_board(board.covered_board);
	        cout << ">> ";
	        getline(cin, input);

	        // Exit and save commands
	        if (input == "quit" || input == "q")
	        {
	            break;
	        }
	        else if (input == "save")
	        {
	        	auto end = chrono::high_resolution_clock::now();
		        auto elapsed = chrono::duration_cast<chrono::seconds>(end - begin);
		        int elapsed_time = elapsed.count();
		        elapsed_time += previous_time;

	        	board.save_board(elapsed_time);
	        	continue;
	        }

	        // Check invalid input, set row col, check row col limits and no repeats
	        if (is_2digit_coord(input))
	        {
	            row = input[0] - 'a';
	            col = input[2] - '0' + 10;
	        }
	        else if (is_1digit_coord(input))
	        {
	            row = input[0] - 'a';
	            col = input[1] - '0';
	        }
	        // if flag function
	        else if (is_2digit_flag(input))
	        {
	            flag = true;
	            row = input[1] - 'a';
	            col = input[3] - '0' + 10;
	        }
	        else if (is_1digit_flag(input))
	        {
	            flag = true;
	            row = input[1] - 'a';
	            col = input[2] - '0';
	        }
	        else
	            continue;

	        // Another check for limit and repeated input
            if (row >= board.ROWS || col >= board.COLS || board.raw_board[row][col] < '0')
                continue;

            // If flag command
            if (flag)
            {
				// Toggle flagging
		        if (board.covered_board[row][col] == '?')
		            board.covered_board[row][col] = '*';
		        else if (board.covered_board[row][col] == '*')
		            board.covered_board[row][col] = '?';
            }
            else
            {
				// Flood fill if the tile is empty, otherwise uncover once
		        if (board.raw_board[row][col] == '0' && board.covered_board[row][col] != '?')
		        {
		            board.flood_fill(row, col);
		        }
		        else if (board.covered_board[row][col] == '*')
		        {
		            board.covered_board[row][col] = board.raw_board[row][col];
		            board.uncovered++;
		        }

		        // Losing condition
		        if (board.raw_board[row][col] == 'X' && board.covered_board[row][col] != '?')
		        {
		            // Stop the timer
		            auto end = chrono::high_resolution_clock::now();
		            auto elapsed = chrono::duration_cast<chrono::seconds>(end - begin);
		            int elapsed_time = elapsed.count();
		            elapsed_time += previous_time;

		            clear_screen();
		            cout << "█▀▀ ▄▀█ █▀▄▀█ █▀▀   █▀█ █ █ █▀▀ █▀█" << endl;
		            cout << "█▄█ █▀█ █ ▀ █ ██▄   █▄█ ▀▄▀ ██▄ █▀▄\n" << endl;

		            board.print_board(board.raw_board);
		            board.print_summary(elapsed_time);

					getline(cin, input);
		            break;
		        }

		        // Winning condition
		        if (board.uncovered == (board.ROWS * board.COLS - board.total_mines))
		        {
		            // Stop the timer
		            auto end = chrono::high_resolution_clock::now();
		            auto elapsed = chrono::duration_cast<chrono::seconds>(end - begin);
		            int elapsed_time = elapsed.count();
		            elapsed_time += previous_time;

		            clear_screen();
		            cout << "█▀▀ █▀█ █▄ █ █▀▀ █▀█ ▄▀█ ▀█▀ █ █ █   ▄▀█ ▀█▀ █ █▀█ █▄ █ █▀" << endl;
		            cout << "█▄▄ █▄█ █ ▀█ █▄█ █▀▄ █▀█  █  █▄█ █▄▄ █▀█  █  █ █▄█ █ ▀█ ▄█\n" << endl;

		            board.print_board(board.raw_board);
		            board.print_summary(elapsed_time);

		            getline(cin, input);
		            break;
		        }
            }
	    }

    }

    return 0;
}
