// MINESWEEPER!!!
// Group 19: Jalik, Raph
// Description: yadayadayada

// ASCII text generated by https://fsymbols.com/text-art/
// Text symbols (in print_board) generated by https://www.madeintext.com/text-symbols/

#include <iostream>
#include <chrono>
#include <limits>
#include "functions.h"
#include "prints.h"
#include "board.h"
using namespace std;


int main()
{
    // Main Menu
    string command;
    bool menu_started = false; // for the cin cout problem

    while (true)
    {
    	// Create instance of a board
    	Board board;

        // Print main menu and get input:
        clear_screen();
        print_title();

        if (menu_started)
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        getline(cin, command);
        menu_started = true;

        if (command == "0")
        {
            clear_screen();
            print_instructions();
            continue;
        }
        else if (command == "1")
        {
            // Initialize board based on difficulty
            board.select_difficulty();
            board.initialize_board();

            string input;
            int row, col;

            // First move: making sure first input isn't near a bomb
            while(true)
            {
				clear_screen();
                board.print_board(board.covered_board);
                cout << ">> ";
                //cin.ignore(numeric_limits<streamsize>::max(), '\n');
                getline(cin, input); // a0, b1, etc.

                if (is_2digit_coord(input))
                {
                    row = input[0] - 'a';
                    col = input[2] - '0' + 10;
                }
                else if (is_1digit_coord(input))
                {
                    row = input[0] - 'a';
                    col = input[1] - '0';
                }
                else
                	continue;

                // Additional check for limit
                if (row >= board.ROWS || col >= board.COLS)
                    continue;

                board.generate_mines(row, col);
                board.generate_clues();
                if (board.raw_board[row][col] == '0')
                    board.flood_fill(row, col);
                else
                	board.covered_board[row][col] = board.raw_board[row][col];
                break;
            }

        }
        else if (command == "2")
        {
        	string input;
			// Load board
		    if (!board.load_board())
		    {
			    cout << "No save file detected\nEnter any value to return to menu" << endl;
	        	cin >> input;
	        	continue;
		    }

            bool game_started = false;
        }
        else if (command == "3")
        {
        	clear_screen();
            print_end();
            break;
        }
        else
        {
            menu_started = false;
            continue;
        }

        /***************** GAME BEGINS *****************/

        // Variables
	    string input;
	    int row, col;
	    bool flag;

	    // Start the timer
	    auto begin = chrono::high_resolution_clock::now();

	    while (true)
	    {
	        flag = false;
	        clear_screen();
	        board.print_board(board.covered_board);
	        //print_board(board, ROWS, COLS);
	        cout << ">> ";
	        cin >> input;

	        // Exit and save commands
	        if (input == "quit" || input == "q")
	        {
	            break;
	        }
	        else if (input == "save")
	        {
	        	board.save_board();
	        	continue;
	        }

	        // Check invalid input, set row col, check valid row col and no repeats
	        if (is_2digit_coord(input))
	        {
	            row = input[0] - 'a';
	            col = input[2] - '0' + 10;
	        }
	        else if (is_1digit_coord(input))
	        {
	            row = input[0] - 'a';
	            col = input[1] - '0';
	        }
	        // if flag function
	        else if (is_2digit_flag(input))
	        {
	            flag = true;
	            row = input[1] - 'a';
	            col = input[3] - '0' + 10;
	        }
	        else if (is_1digit_flag(input))
	        {
	            flag = true;
	            row = input[1] - 'a';
	            col = input[2] - '0';
	        }
	        else
	            continue;

	        // Another check for limit and repeated input
            if (row >= board.ROWS || col >= board.COLS || board.raw_board[row][col] < '0')
                continue;

            // If flag command
            if (flag)
            {
				// Toggle flagging
		        if (board.covered_board[row][col] == '?')
		            board.covered_board[row][col] = '*';
		        else if (board.covered_board[row][col] == '*')
		            board.covered_board[row][col] = '?';
            }
            else
            {
				// Flood fill if the tile is empty, otherwise uncover once
		        if (board.raw_board[row][col] == '0' && board.covered_board[row][col] != '?')
		        {
		            board.flood_fill(row, col);
		        }
		        else if (board.covered_board[row][col] == '*')
		        {
		            board.covered_board[row][col] = board.raw_board[row][col];
		            board.uncovered++;
		        }

		        // Losing condition
		        if (board.raw_board[row][col] == 'X' && board.covered_board[row][col] != '?')
		        {
		            // Stop the timer
		            auto end = chrono::high_resolution_clock::now();
		            auto elapsed = chrono::duration_cast<chrono::seconds>(end - begin);

		            clear_screen();
		            cout << "█▀▀ ▄▀█ █▀▄▀█ █▀▀   █▀█ █ █ █▀▀ █▀█" << endl;
		            cout << "█▄█ █▀█ █ ▀ █ ██▄   █▄█ ▀▄▀ ██▄ █▀▄\n" << endl;

		            board.print_board(board.raw_board);
		            // cout << endl;
		            board.print_summary(elapsed.count());

					cin >> input;
		            break;
		        }

		        // Winning condition
		        if (board.uncovered == (board.ROWS * board.COLS - board.total_mines))
		        {
		            // Stop the timer
		            auto end = chrono::high_resolution_clock::now();
		            auto elapsed = chrono::duration_cast<chrono::seconds>(end - begin);

		            clear_screen();
		            cout << "█▀▀ █▀█ █▄ █ █▀▀ █▀█ ▄▀█ ▀█▀ █ █ █   ▄▀█ ▀█▀ █ █▀█ █▄ █ █▀" << endl;
		            cout << "█▄▄ █▄█ █ ▀█ █▄█ █▀▄ █▀█  █  █▄█ █▄▄ █▀█  █  █ █▄█ █ ▀█ ▄█\n" << endl;

		            board.print_board(board.raw_board);
		            // cout << endl;
		            board.print_summary(elapsed.count());

		            cin >> input;
		            break;
		        }
            }
	    }

    }

    return 0;
}
